const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const EXTRACTOR_SCRIPT = path.join(__dirname, 'extract_simple.js');
const SOURCE_FILE = path.join(__dirname, '../public/guides/html/Toyota_Lexus_Key_System_Dossier.html');
const OUTPUT_SQL = path.join(__dirname, '../data/migrations/seed_forensic_evidence.sql');

console.log("üöÄ Starting Forensic Ingestion...");

try {
    // 1. Run the extractor
    console.log(`Running extractor on ${path.basename(SOURCE_FILE)}...`);
    const output = execSync(`node ${EXTRACTOR_SCRIPT} ${SOURCE_FILE}`).toString();

    // The extractor prints logs to stdout too, so we need to find the JSON array.
    // We assume the JSON is the last block or parseable.
    // Actually, extract_simple.js prints logs then JSON. We should try to find the [ ... ].

    const jsonStart = output.indexOf('[');
    const jsonEnd = output.lastIndexOf(']') + 1;

    if (jsonStart === -1 || jsonEnd === 0) {
        throw new Error("Could not find JSON output from extractor");
    }

    const jsonStr = output.substring(jsonStart, jsonEnd);
    const data = JSON.parse(jsonStr);

    console.log(`Parsed ${data.length} records.`);

    // 2. Transform to SQL
    let sql = `-- Seed Forensic Evidence from Toyota Dossier\n`;
    sql += `-- Generated by scripts/ingest_forensic_evidence.js\n\n`;

    let count = 0;

    data.forEach(item => {
        if (!item.fcc_id) return; // FCC ID is required for linking

        let fcc = item.fcc_id.toUpperCase().replace(/[^A-Z0-9]/g, '');

        // Validation: Filter out garbage (e.g. base64 fragments)
        if (fcc.length < 4 || fcc.length > 20) return;
        if (/^(NOTE|THE|AND|FOR|REFERENCE)$/.test(fcc)) return;

        // heuristic: base64 often has many consecutive random chars, but real FCCs are usually structured.
        // If it's very long (e.g. > 15) and not a known pattern, maybe skip?
        // But some IC numbers are long. Let's start with length > 20 reject.

        const sourceRef = 'Toyota_Lexus_Key_System_Dossier.html';
        const sourceType = 'forensic_extraction';
        const confidence = 90;

        // Helper to add row
        const addRow = (field, val) => {
            if (!val) return;
            // Escape single quotes
            const safeVal = val.replace(/'/g, "''");
            sql += `INSERT INTO fcc_evidence (fcc_id, field_name, value, source_type, source_ref, confidence_score) VALUES ('${fcc}', '${field}', '${safeVal}', '${sourceType}', '${sourceRef}', ${confidence});\n`;
            count++;
        };

        addRow('chip', item.chip_id);
        addRow('board_id', item.board_id);
        addRow('oem_part', item.oem_part);

        // Add context as notes if available
        if (item.context_model) {
            addRow('verified_context', `${item.context_model} (${item.context_year})`);
        }

        // Infer frequency if present in raw text (naive)
        if (item.raw && item.raw.match(/315\s*MHz/i)) addRow('frequency', '315 MHz');
        if (item.raw && item.raw.match(/312\/314\s*MHz/i)) addRow('frequency', '312/314 MHz');
        if (item.raw && item.raw.match(/433\s*MHz/i)) addRow('frequency', '433 MHz');
    });

    // 3. Write to file
    fs.writeFileSync(OUTPUT_SQL, sql);
    console.log(`‚úÖ Generated ${count} evidence records in ${OUTPUT_SQL}`);

} catch (e) {
    console.error("‚ùå Error:", e.message);
    process.exit(1);
}
