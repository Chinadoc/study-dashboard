import json
import re
import os

# Define the set of known makes to help with parsing the title
KNOWN_MAKES = [
    'Acura', 'Audi', 'BMW', 'Buick', 'Cadillac', 'Chevrolet', 'Chrysler', 'Dodge',
    'Fiat', 'Ford', 'GMC', 'Honda', 'Hyundai', 'Infiniti', 'Jaguar', 'Jeep',
    'Kia', 'Land Rover', 'Lexus', 'Lincoln', 'Mazda', 'Mercedes-Benz', 'Mini',
    'Mitsubishi', 'Nissan', 'Porsche', 'Ram', 'Subaru', 'Toyota', 'Volkswagen', 'Volvo',
    'Oldsmobile', 'Pontiac', 'Saturn', 'Scion', 'Suzuki', 'Genesis', 'Hummer', 'Isuzu',
    'Maserati', 'Aston Martin', 'Bentley', 'Ferrari', 'Lamborghini', 'Lotus', 'McLaren'
]

def clean_sql(val):
    if val is None:
        return 'NULL'
    if isinstance(val, int):
        return str(val)
    return "'" + str(val).replace("'", "''") + "'"

def parse_year_range(range_str):
    """Parses strings like '2017-2022' or '2024' or '2022 onwards'"""
    range_str = range_str.lower().strip()
    
    # Handle '2022-2025'
    match = re.search(r'(\d{4})\s*-\s*(\d{4})', range_str)
    if match:
        return int(match.group(1)), int(match.group(2))
    
    # Handle single year '2024'
    match = re.search(r'^(\d{4})$', range_str)
    if match:
        return int(match.group(1)), int(match.group(1))
    
    # Handle '2022 onwards' or '2022-present'
    match = re.search(r'(\d{4})\s*(?:onwards|present|\+)', range_str)
    if match:
        return int(match.group(1)), 2026 
    
    return None, None

def extract_fcc_id(text):
    if not text:
        return None
    
    text = text.upper()
    
    # Prioritize known FCC prefixes
    fcc_patterns = [
        r'FCC\s*ID:\s*([A-Z0-9-]+)',
        r'FCC\s*([A-Z0-9-]+)',
        r'(HYQ[A-Z0-9]+)',
        r'(NBG[A-Z0-9]+)',
        r'(N5F[A-Z0-9]+)',
        r'(SY5[A-Z0-9]+)',
        r'(CWTWB[A-Z0-9]+)',
        r'(M3N[A-Z0-9]+)',
        r'(KR5[A-Z0-9]+)',
        r'(GQ4[A-Z0-9]+)',
        r'(OUC[A-Z0-9]+)',
        r'(MYT[A-Z0-9]+)',
        r'(HLIK[A-Z0-9]+)'
    ]
    
    blacklist = [
        'PHILIPS', 'MAXELL', 'XHORSE', 'STRATTEC', 'DURACELL', 'ENERGIZER', 
        'HONDA', 'ACURA', 'CHEVY', 'TOYOTA', 'FORD', 'NISSAN', 'HYUNDAI', 'KIA',
        'SMART', 'REMOTE', 'KEYLESS', 'BATTERY', 'BUTTON', 'MECHANICAL'
    ]

    for pattern in fcc_patterns:
        match = re.search(pattern, text)
        if match:
            fcc = match.group(1).strip('-')
            # Avoid matching year ranges like '2013-2015'
            if re.match(r'^\d{4}-\d{4}$', fcc):
                continue
            if fcc in blacklist:
                continue
            return fcc
            
    # Fallback to general pattern but avoid year ranges and blacklist
    match = re.search(r'\(([A-Z0-9]{5,})\)', text) # (KR5434760)
    if match:
        fcc = match.group(1)
        if fcc not in blacklist:
            return fcc
        
    return None

def main():
    jsonl_path = 'data/aks_id_data.jsonl'
    output_sql = 'data/migrations/import_aks_2024_2026.sql'
    
    if not os.path.exists(jsonl_path):
        print(f"File not found: {jsonl_path}")
        return

    sql_statements = [
        "-- Migration: Import 2024-2026 Vehicle Data from AKS Scrape",
        "-- Generated by scripts/ingest_aks_data.py",
        ""
    ]
    
    unique_entries = set() # To avoid duplicates
    count = 0
    
    with open(jsonl_path, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                data = json.loads(line)
            except:
                continue
                
            title = data.get('vehicle_title', '')
            if not title:
                continue
                
            parts = [p.strip() for p in title.split('\n') if p.strip()]
            if not parts:
                continue
                
            first_line = parts[0]
            make = None
            model = None
            
            for km in KNOWN_MAKES:
                if first_line.startswith(km):
                    make = km
                    model = first_line[len(km):].strip()
                    break
            
            if not make:
                sp = first_line.split(' ', 1)
                make = sp[0]
                model = sp[1] if len(sp) > 1 else 'Unknown'
                
            year_ranges = []
            has_new_years = False
            for ypart in parts[1:]:
                y_start, y_end = parse_year_range(ypart)
                if y_start:
                    year_ranges.append((y_start, y_end))
                    if y_end >= 2024:
                        has_new_years = True
            
            if not year_ranges:
                y_start, y_end = parse_year_range(first_line)
                if y_start:
                    year_ranges.append((y_start, y_end))
                    if y_end >= 2024:
                        has_new_years = True
            
            if not has_new_years:
                continue
                
            specs = data.get('specs', {})
            chip = specs.get('chip') or specs.get('transponder_key')
            if chip == 'N/A': chip = None
            
            lishi = specs.get('lishi')
            if lishi == 'N/A': lishi = None
            
            # Keyway / Blade
            keyway = specs.get('mechanical_key')
            if keyway == 'N/A': keyway = None

            # Collect all technical variants (mainly by FCC ID)
            variants = []
            fcc_from_specs = specs.get('fcc_id')
            if fcc_from_specs and fcc_from_specs != 'N/A' and not re.match(r'^\d{4}-\d{4}$', fcc_from_specs):
                variants.append({'fcc_id': fcc_from_specs})
            
            # Extract from products
            for prod in data.get('products', []):
                fcc = extract_fcc_id(prod.get('title', ''))
                if fcc and not any(v['fcc_id'] == fcc for v in variants):
                    variants.append({'fcc_id': fcc})
            
            if not variants:
                variants.append({'fcc_id': None})

            # Key Type extraction
            key_type = 'Standard'
            all_text = (title + " " + " ".join([p.get('title', '') for p in data.get('products', [])])).lower()
            if 'smart' in all_text or 'proximity' in all_text or 'prox' in all_text:
                key_type = 'Smart Key'
            elif 'flip' in all_text:
                key_type = 'Flip Key'
            elif 'remote head' in all_text:
                key_type = 'Remote Head Key'
            elif 'fobik' in all_text:
                key_type = 'Fobik'
            elif 'transponder' in all_text:
                key_type = 'Transponder Key'

            for y_start, y_end in year_ranges:
                if y_end < 2024:
                    continue
                                    
                for var in variants:
                    v_fcc = var['fcc_id']
                    
                    # Create a unique key for deduplication
                    ukey = (make, model, y_start, y_end, v_fcc, chip, lishi, keyway, key_type)
                    if ukey in unique_entries:
                        continue
                    unique_entries.add(ukey)
                    
                    stmt = f"INSERT OR REPLACE INTO vehicles (make, model, year_start, year_end, chip, lishi_tool, fcc_id, keyway, key_type, source_name, confidence_score) VALUES ("
                    stmt += f"{clean_sql(make)}, "
                    stmt += f"{clean_sql(model)}, "
                    stmt += f"{y_start}, "
                    stmt += f"{y_end}, "
                    stmt += f"{clean_sql(chip)}, "
                    stmt += f"{clean_sql(lishi)}, "
                    stmt += f"{clean_sql(v_fcc)}, "
                    stmt += f"{clean_sql(keyway)}, "
                    stmt += f"{clean_sql(key_type)}, "
                    stmt += f"'americankeysupply_scrape', 0.8);"
                    
                    sql_statements.append(stmt)
                    count += 1
                
    with open(output_sql, 'w', encoding='utf-8') as f:
        f.write("\n".join(sql_statements))
        
    print(f"Generated {count} SQL statements in {output_sql}")

if __name__ == "__main__":
    main()
